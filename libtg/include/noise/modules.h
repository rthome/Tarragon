#pragma once

#include <cstdint>
#include <functional>

#include <glm/vec3.hpp>
#include <glm/gtc/constants.hpp>

#include "noise/common.h"

namespace tarragon::noise
{
    using Module = std::function<double(glm::dvec3)>;

    enum class CellType
    {
        Voronoi,
        Euclidean = Voronoi,
        Quadratic,
        Manhattan,
        Chebychev,
        Minkowsky
    };

    struct ControlPoint
    {
        double Input;
        double Output;
    };

    constexpr NoiseQuality DefaultQuality = NoiseQuality::Standard;
    constexpr int32_t DefaultSeed = 0;

    constexpr double BillowDefaultFrequency = 1.0;
    constexpr double BillowDefaultLacunarity = 2.0;
    constexpr uint32_t BillowDefaultOctaveCount = 6;
    constexpr double BillowDefaultPersistence = 0.5;

    constexpr CellType CellDefaultType = CellType::Voronoi;
    constexpr double CellDefaultDisplacement = 1.0;
    constexpr double CellDefaultFrequency = 1.0;
    constexpr bool CellDefaultEnableDistance = false;
    constexpr double CellDefaultMinkowskyCoefficient = 4.0;

    constexpr double ClampDefaultLowerBound = -1.0;
    constexpr double ClampDefaultUpperBound = 1.0;

    constexpr double ConstantDefaultValue = 0.0;

    constexpr double CylindersDefaultFrequency = 1.0;

    constexpr double ExponentDefaultExponent = 1.0;

    constexpr double PerlinDefaultFrequency = 1.0;
    constexpr double PerlinDefaultLacunarity = 2.0;
    constexpr uint32_t PerlinDefaultOctaveCount = 6;
    constexpr double PerlinDefaultPersistence = 0.5;

    constexpr double RidgedMultiDefaultFrequency = 1.0;
    constexpr double RidgedMultiDefaultLacunarity = 2.0;
    constexpr uint32_t RidgedMultiDefaultOctaveCount = 6;
    constexpr uint32_t RidgedMultiMaxOctaveCount = 30;

    constexpr double RotateDefaultAngle = 0.0;

    constexpr double ScaleBiasDefaultScale = 1.0;
    constexpr double ScaleBiasDefaultBias = 0.0;

    constexpr glm::dvec3 ScalePointDefaultScaleFactor = glm::one<glm::dvec3>();

    constexpr double SelectDefaultLowerBound = -1.0;
    constexpr double SelectDefaultUpperBound = 1.0;
    constexpr double SelectDefaultEdgeFalloff = 0.0;

    constexpr double SimplexDefaultFrequency = 1.0;
    constexpr double SimplexDefaultLacunarity = 2.0;
    constexpr uint32_t SimplexDefaultOctaveCount = 6;
    constexpr double SimplexDefaultPersistence = 0.5;

    constexpr double SpheresDefaultFrequency = 1.0;

    constexpr bool TerraceDefaultInvertTerraces = false;

    constexpr glm::dvec3 TranslateDefaultTranslation = glm::zero<glm::dvec3>();

    constexpr double TurbulenceDefaultFrequency = PerlinDefaultFrequency;
    constexpr double TurbulenceDefaultPower = 1.0;
    constexpr int32_t TurbulenceDefaultRoughness = 3;

    constexpr uint32_t WhiteDefaultScale = 256;

    // Outputs the absolute value of the source value
    Module Abs(Module source);

    // Outputs the sum of the source values
    Module Add(Module source0, Module source1);

    // Generates "billowy" noise suitable for clouds and rocks
    //
    // This noise module generates "billowy" noise suitable for clouds and
    // rocks. It is nearly identical to Perlin except
    // this noise module modifies each octave with an absolute-value
    // function. See the documentation of Perlin for more information.
    //
    // frequency:
    //     The frequency of the first octave
    //
    // lacunarity:
    //     The lacunarity is the frequency multiplier between successive
    //     octaves.
    //
    // octave_count:
    //     The number of octaves that generate the billowy noise. The number
    //     of octaves controls the amount of detail in the billowy noise.
    //
    // persistence:
    //     The persistence value controls the roughness of the billowy noise.
    //
    // quality:
    //     The quality of the billowy noise
    //
    // seed:
    //     The seed value used by the billowy-noise function
    Module Billow(
        double frequency = BillowDefaultFrequency,
        double lacunarity = BillowDefaultLacunarity,
        uint32_t octave_count = BillowDefaultOctaveCount,
        double persistence = BillowDefaultPersistence,
        NoiseQuality quality = DefaultQuality,
        int32_t seed = DefaultSeed);

    // Outputs a weighted blend of the output values from two sources,
    // given the output value supplied by a control source
    //
    // Modules source0 and source1 generate the values to blend. The
    // control module determines the weight of the blending operation.
    // Negative values weigh the blend towards the output of source0.
    // Positive values weigh the blend towards the output of source1.
    // This module uses linear interpolation to perform the blending.
    Module Blend(Module source0, Module source1, Module control);
    
    // Caches the last output value generated by its source (per thread)
    //
    // If an application passes an input position that differs from the
    // previously passed-in input value, this noise module instructs
    // the source module to calculate the output value. This value,
    // as well as the input position, are cached in this noise module.
    //
    // If the application passes an input position that is equal to
    // the previously passed-in input value, this noise module
    // returns the cached output value without having the source
    // module recalculate the output value.
    //
    // Caching a noise module is useful if it is used as a source module for
    // multiple noise modules. If a source module is not cached, the source
    // module will redundantly calculate the same output value once for each
    // noise module in which it is included.
    Module Cache(Module source);
    
    // Outputs cell noise
    //
    // In mathematics, a Voronoi cell is a region containing all the
    // points that are closer to a specific seed point than to any
    // other seed point. These cells mesh with one another, producing
    // polygon-like formations.
    //
    // By default, this noise module randomly places a seed point within
    // each unit cube. By modifying the frequency of the seed points,
    // an application can change the distance between seed points. The
    // higher the frequency, the closer together this noise module places
    // the seed points, which reduces the size of the cells.
    //
    // This noise module assigns each cell with a random constant
    // value from a coherent-noise function. The displacement value
    // controls the range of random values to assign to each cell. The
    // range of random values is +/- the displacement value.
    //
    // This noise module can optionally add the distance from the nearest
    // seed to the output value. This causes the points in the Voronoi cells
    // to increase in value the further away that point is from the nearest
    // seed point.
    //
    // Cells are often used to generate cracked-mud terrain
    // formations or crystal-like textures.
    //
    // type:
    //     Type of cell noise to generate
    //
    // displacement:
    //     Controls the range of random values to assign to each cell.
    //     The range of random values is +/- the displacement value.
    //
    // frequency:
    //     determines the size of the cells and the distance between them.
    //
    // enable_distance:
    //     Applying the distance from the nearest seed point to the output
    //     value causes the points in the cells to increase in value
    //     the further away that point is from the nearest seed point.
    //     Setting this value to true (and setting the displacement to a
    //     near-zero value) causes this noise module to generate cracked mud
    //     formations.
    //
    // minkowsky_coefficient:
    //     Modifies the cell generation for the Minkowsky cell type
    //
    // seed:
    //     The seed value used by the Cell generator
    Module Cell(
        CellType type = CellDefaultType,
        double displacement = CellDefaultDisplacement,
        double frequency = CellDefaultFrequency,
        bool enable_distance = CellDefaultEnableDistance,
        double minkowsky_coefficient = CellDefaultMinkowskyCoefficient,
        int32_t seed = DefaultSeed);

    // Outputs a checkerboard pattern
    //
    // This noise module outputs unit-sized blocks of alternating values.
    // The values of these blocks alternate between -1.0 and +1.0.
    // Sometimes useful for debugging purposes.
    Module Checkerboard();

    // Outputs source values clamped into a range
    //
    // The range of values in which to clamp the output value is called the
    // clamping range.
    // If the output value from the source module is less than the lower
    // bound of the clamping range, this noise module clamps that value to
    // the lower bound. If the output value from the source module is
    // greater than the upper bound of the clamping range, this noise module
    // clamps that value to the upper bound.
    Module Clamp(
        Module source,
        double lower_bound = ClampDefaultLowerBound,
        double upper_bound = ClampDefaultUpperBound);

    // Outputs a constant value
    //
    // Not really useful by itself, but often used as a source module.
    Module Constant(double value = ConstantDefaultValue);

    // Maps the output value from a source module onto an
    // arbitrary function curve created by the given control points
    //
    // This noise module maps the output value from the source module onto an
    // application-defined curve. This curve is defined by a number of
    // control points; each control point has an input value
    // that maps to an output value.
    // 
    // Since this curve is a cubic spline, an application must add a minimum
    // of four control points to the curve. If this is not done, the module fails.
    // 
    // Each control point can have any input and output value,
    // although no two control points can have the same input value.
    // There is no limit to the number of control points that can be
    // added to the curve.
    //
    // control_points:
    //     Array of control points with input and ouput values,
    //     that form the curve. Must contain at least four control points.
    //
    // control_point_count:
    //     Number of control points to copy from the given array
    Module Curve(Module source, ControlPoint const *control_points, size_t control_point_count);

    // Outputs concentric cylinders
    //
    // This noise module outputs concentric cylinders centered on the origin.
    // These cylinders are oriented along the y axis similar to the
    // concentric rings of a tree. Each cylinder extends infinitely along
    // the y axis.
    //
    // The first cylinder has a radius of 1.0. Each subsequent cylinder has
    // a radius that is 1.0 unit larger than the previous cylinder.
    //
    // The output value from this noise module is determined by the distance
    // between the input value and the the nearest cylinder surface. The
    // input values that are located on a cylinder surface are given the
    // output value 1.0 and the input values that are equidistant from two
    // cylinder surfaces are given the output value -1.0.
    //
    // An application can change the frequency of the concentric cylinders.
    // Increasing the frequency reduces the distances between cylinders.
    //
    // This noise module, modified with some low-frequency, low-power
    // turbulence, is useful for generating wood-like textures.
    //
    // frequency:
    //     The frequency of the concentric cylinders.
    //     Increasing the frequency increases the density of the concentric
    //     cylinders, reducing the distances between them.
    Module Cylinders(double frequency = CylindersDefaultFrequency);

    // Uses three source modules to displace each coordinate 
    // of the input value before returning the output value from
    // a source module.
    //
    // This noise module modifies the coordinates of the input value using
    // the output values from the three displacement modules
    // before retrieving the output value from the source module.
    //
    // The Turbulence noise module is a special case of the
    // displacement module; internally, there are three Perlin-noise modules
    // that perform the displacement operation.
    Module Displace(
        Module source,
        Module xdisplace,
        Module ydisplace,
        Module zdisplace);

    // Maps the output value from a source module onto an exponential curve
    //
    // Because most noise modules will output values that range from -1.0 to
    // +1.0, this noise module first normalizes this output value (the range
    // becomes 0.0 to 1.0), maps that value onto an exponential curve, then
    // rescales that value back to the original range.
    //
    // exponent:
    //     The exponent value to apply to the output value from the
    //     source module.
    Module Exponent(Module source, double exponent = ExponentDefaultExponent);

    // Inverts the output value from a source module
    Module Invert(Module source);

    // Outputs the larger of the two output values from two source modules
    Module Max(Module source0, Module source1);

    // Outputs the smaller of the two output values from two source modules
    Module Min(Module source0, Module source1);

    // Outputs the product of the two output values from two source modules
    Module Multiply(Module source0, Module source1);

    // Outputs 3-dimensional Perlin noise
    //
    // Perlin noise is the sum of several coherent-noise functions of
    // ever-increasing frequencies and ever-decreasing amplitudes.
    //
    // An important property of Perlin noise is that a small change in the
    // input value will produce a small change in the output value, while a
    // large change in the input value will produce a random change in the
    // output value.
    //
    // This noise module outputs Perlin-noise values that usually range from
    // -1.0 to +1.0, but there are no guarantees that all output values will
    // exist within that range.
    // 
    // For a better description of Perlin noise, see:
    //     https://en.wikipedia.org/wiki/Perlin_noise
    //
    // frequency:
    //     The frequency of the first octave
    //
    // lacunarity:
    //     The lacunarity of the Perlin noise.
    // 
    //     The lacunarity specifies the frequency multipler between successive
    //     octaves.
    //     The effect of modifying the lacunarity is subtle; you may need to play
    //     with the lacunarity value to determine the effects.  For best results,
    //     set the lacunarity to a number between 1.5 and 3.5.
    //
    // octave_count:
    //     The number of octaves that generate Perlin noise.
    // 
    //     The number of octaves control the amount of detail of the
    //     Perlin noise. Adding more octaves increases the detail of the Perlin
    //     noise, but with the drawback of increasing the calculation time.
    //     
    //     An octave is one of the coherent-noise functions in a series of
    //     coherent-noise functions that are added together to form Perlin
    //     noise.
    //     
    //     These coherent-noise functions are called octaves because each octave
    //     has, by default, double the frequency of the previous octave. Musical
    //     tones have this property as well; a musical C tone that is one octave
    //     higher than the previous C tone has double its frequency.
    //
    // persistence:
    //     Controls the roughness of the Perlin noise. Larger values produce rougher noise.
    //     
    //     The persistence value determines how quickly the amplitudes diminish
    //     for successive octaves. The amplitude of the first octave is 1.0.
    //     The amplitude of each subsequent octave is equal to the product of the
    //     previous octave's amplitude and the persistence value. So a
    //     persistence value of 0.5 sets the amplitude of the first octave to
    //     1.0; the second, 0.5; the third, 0.25; etc.
    //
    // quality:
    //     The quality of the Perlin noise
    //
    // seed:
    //     The seed value used by the Perlin-noise function
    Module Perlin(
        double frequency = PerlinDefaultFrequency,
        double lacunarity = PerlinDefaultLacunarity,
        uint32_t octave_count = PerlinDefaultOctaveCount,
        double persistence = PerlinDefaultPersistence,
        NoiseQuality quality = DefaultQuality,
        int32_t seed = DefaultSeed);
    
    // Raises the output value from a first source module
    // to the power of the output value from a second source module
    Module Power(Module source0, Module source1);

    // Outputs 3-dimensional ridged-multifractal noise
    //
    // This noise module, heavily based on the Perlin-noise module, generates
    // ridged-multifractal noise. Ridged-multifractal noise is generated in
    // much of the same way as Perlin noise, except the output of each octave
    // is modified by an absolute-value function. Modifying the octave
    // values in this way produces ridge-like formations.
    //
    // Ridged-multifractal noise does not use a persistence value. This is
    // because the persistence values of the octaves are based on the values
    // generated from from previous octaves, creating a feedback loop (or
    // that's what it looks like after reading the code.)
    //
    // This noise module outputs ridged-multifractal-noise values that
    // usually range from -1.0 to +1.0, but there are no guarantees that all
    // output values will exist within that range. For ridged-multifractal noise
    // generated with only one octave, the output value ranges from -1.0 to 0.0.
    //
    // Ridged-multifractal noise is often used to generate craggy mountainous
    // terrain or marble-like textures.
    //
    // frequency:
    //     The frequency of the first octave.
    // 
    // lacunarity:
    //     The frequency multipler between successive octaves.
    // 
    //     The effect of modifying the lacunarity is subtle; you may need to play
    //     with the lacunarity value to determine the effects. For best results,
    //     set the lacunarity to a number between 1.5 and 3.5.
    // 
    // octave_count:
    //     The number of octaves that generate ridged-multifractal noise.
    // 
    //     The number of octaves control the amount of detail of the
    //     ridged-multifractal noise. Adding more octaves increases the detail
    //     of the ridged-multifractal noise, but with the drawback of increasing
    //     the calculation time.
    //
    // quality:
    //     The quality of the Perlin noise
    //
    // seed:
    //     The seed value used by the Perlin-noise function
    Module RidgedMulti(
        double frequency = RidgedMultiDefaultFrequency,
        double lacunarity = RidgedMultiDefaultLacunarity,
        uint32_t octave_count = RidgedMultiDefaultOctaveCount,
        NoiseQuality quality = DefaultQuality,
        int32_t seed = DefaultSeed);

    // Rotates the input value around the origin before
    // returning the output value from a source module
    Module Rotate(
        Module source,
        double xdegrees = RotateDefaultAngle,
        double ydegrees = RotateDefaultAngle,
        double zdegrees = RotateDefaultAngle);
    
    // Applies a scaling factor and a bias to the output value from a source module
    Module ScaleBias(
        Module source,
        double scale = ScaleBiasDefaultScale,
        double bias = ScaleBiasDefaultBias);

    // Scales the coordinates of the input value before
    // returning the output value from a source module
    Module ScalePoint(
        Module source,
        glm::dvec3 const& scale_factor = ScalePointDefaultScaleFactor);

    // Outputs the value selected from one of two source
    // modules chosen by the output value from a control module
    //
    // The control module determines the value to select. If the output
    // value from the control module is within a range of values
    // known as the selection range, this noise module outputs the
    // value of source1. Otherwise, this noise module outputs
    // the value of source0.
    //
    // By default, there is an abrupt transition between the output values
    // from the two source modules at the selection-range boundary.  To
    // smooth the transition, pass a non-zero value as edge_falloff.
    // Higher values result in a smoother transition.
    //
    // lower_bound:
    //     The lower bound of the selection range.
    //
    // upper_bound:
    //     The upper bound of the selection range.
    //
    // edge_falloff:
    //     The falloff value at the edge transition.
    // 
    //     The falloff value is the width of the edge transition at either
    //     edge of the selection range.
    //     
    //     By default, there is an abrupt transition between the output
    //     values from the two source modules at the selection-range
    //     boundary.
    //     
    //     For example, if the selection range is 0.5 to 0.8, and the edge
    //     falloff value is 0.1, then the output is:
    //       - the output value from source0 if the output value
    //         from the control module is less than 0.4 (= 0.5 - 0.1).
    //       - a linear blend between the two output values from the two source
    //         modules if the output value from the control module is between
    //         0.4 (= 0.5 - 0.1) and 0.6 (= 0.5 + 0.1).
    //       - the output value from source1 if the output value from the control
    //         module is between 0.6 (= 0.5 + 0.1) and 0.7 (= 0.8 - 0.1).
    //       - a linear blend between the output values from the two source
    //         modules if the output value from the control module is between
    //         0.7 (= 0.8 - 0.1) and 0.9 (= 0.8 + 0.1).
    //       - the output value from source0  if the output value from the control
    //         module is greater than 0.9 (= 0.8 + 0.1).
    Module Select(
        Module source0,
        Module source1,
        Module control,
        double lower_bound = SelectDefaultLowerBound,
        double upper_bound = SelectDefaultUpperBound,
        double edge_falloff = SelectDefaultEdgeFalloff);

    // TODO
    // Outputs 3-dimensional Simplex noise
    Module Simplex(
        double frequency = SimplexDefaultFrequency,
        double lacunarity = SimplexDefaultLacunarity,
        uint32_t octave_count = SimplexDefaultOctaveCount,
        double persistence = SimplexDefaultPersistence,
        NoiseQuality quality = DefaultQuality,
        int32_t seed = DefaultSeed);
    
    // Outputs concentric spheres
    //
    // This noise module outputs concentric spheres centered on the origin
    // like the concentric rings of an onion.
    //
    // The first sphere has a radius of 1.0. Each subsequent sphere has a
    // radius that is 1.0 unit larger than the previous sphere.
    //
    // The output value from this noise module is determined by the distance
    // between the input value and the the nearest spherical surface. The
    // input values that are located on a spherical surface are given the
    // output value 1.0 and the input values that are equidistant from two
    // spherical surfaces are given the output value -1.0.
    //
    // This noise module, modified with some low-frequency, low-power
    // turbulence, is useful for generating agate-like textures.
    Module Spheres(double frequency = SpheresDefaultFrequency);

    // Maps the output value from a source module onto a terrace-forming curve
    //
    // This noise module maps the output value from the source module onto a
    // terrace-forming curve. The start of this curve has a slope of zero;
    // its slope then smoothly increases. This curve also contains
    // control points which resets the slope to zero at that point,
    // producing a "terracing" effect.
    // 
    // An application must add a minimum of two control points to the curve.
    // If this is not done, the module fails. The control points
    // can have any value, although no two control points can have the same
    // value.  There is no limit to the number of control points that can be
    // added to the curve.
    //
    // This noise module clamps the output value from the source module if
    // that value is less than the value of the lowest control point or
    // greater than the value of the highest control point.
    //
    // This noise module is often used to generate terrain features such as
    // your stereotypical desert canyon.
    //
    // control_points:
    //     Array of control points with input and ouput values,
    //     that form the terrace-forming curve.
    //     Must contain at least two control points.
    //
    // control_point_count:
    //     Number of control points to copy from the given array
    //
    // invert_terraces:
    //     Enables or disables the inversion of the terrace-forming curve
    //     between the control points.
    Module Terrace(
        Module source,
        double const *control_points,
        size_t control_point_count,
        bool invert_terraces = TerraceDefaultInvertTerraces);

    // Moves the coordinates of the input value before
    // returning the output value from a source module
    Module TranslatePoint(
        Module source,
        glm::dvec3 const& translation = TranslateDefaultTranslation);

    // Randomly displaces the input value before
    // returning the output value from a source module
    //
    // Turbulence is the pseudo-random displacement of the input value coordinates
    // of the input value before retrieving the output value from the source module.
    //
    // Use of this noise module may require some trial and error. Assuming
    // that you are using a generator module as the source module, you
    // should first:
    //   - Set the frequency to the same frequency as the source module.
    //   - Set the power to the reciprocal of the frequency.
    // 
    // From these initial frequency and power values, modify these values
    // until this noise module produce the desired changes in your terrain or
    // texture. For example:
    //   - Low frequency (1/8 initial frequency) and low power (1/8 initial
    //     power) produces very minor, almost unnoticeable changes.
    //   - Low frequency (1/8 initial frequency) and high power (8 times
    //     initial power) produces "ropey" lava-like terrain or marble-like
    //     textures.
    //   - High frequency (8 times initial frequency) and low power (1/8
    //     initial power) produces a noisy version of the initial terrain or
    //     texture.
    //   - High frequency (8 times initial frequency) and high power (8 times
    //     initial power) produces nearly pure noise, which isn't entirely
    //     useful.
    // 
    // Displacing the input values result in more realistic terrain and
    // textures. If you are generating elevations for terrain height maps,
    // you can use this noise module to produce more realistic mountain
    // ranges or terrain features that look like flowing lava rock. If you
    // are generating values for textures, you can use this noise module to
    // produce realistic marble-like or "oily" textures.
    // 
    // frequency:
    //     The frequency of the turbulence determines how rapidly the
    //     displacement amount changes
    //
    // power:
    //     The power of the turbulence determines the scaling factor that is
    //     applied to the displacement amount.
    //
    // roughness:
    //     The roughness of the turbulence determines the roughness of the
    //     changes to the displacement amount. Low values smoothly change the
    //     displacement amount. High values roughly change the displacement
    //     amount, which produces more "kinky" changes.
    //
    // seed:
    //     The seed value of the three internal Perlin-noise modules that
    //     are used to displace each coordinate of the input position.
    Module Turbulence(
        Module source,
        double frequency = TurbulenceDefaultFrequency,
        double power = TurbulenceDefaultPower,
        double roughness = TurbulenceDefaultRoughness,
        int32_t seed = DefaultSeed);

    // Outputs 3-dimensional White noise
    Module White(
        int32_t scale = WhiteDefaultScale,
        int32_t seed = DefaultSeed);
}
